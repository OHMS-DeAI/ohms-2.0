type ArtifactChunkInfo = record {
  sha256 : text;
  size_bytes : nat64;
  offset : nat64;
  chunk_id : text;
};
type ArtifactChunkUpload = record {
  sha256 : text;
  order : nat32;
  data : blob;
  chunk_id : text;
};
type ComponentHealth = variant { Unhealthy; Healthy; Degraded; Unknown };
type InferenceRequest = record {
  session_id : opt text;
  temperature : opt float32;
  timeout_ms : opt nat64;
  max_tokens : opt nat32;
  model_id : text;
  input_data : blob;
};
type InferenceResponse = record {
  tokens_processed : nat32;
  model_version : text;
  session_id : text;
  processing_time_ms : nat64;
  output_data : blob;
  confidence_score : opt float32;
};
type ModelCanisterMetrics = record {
  deleted_models : nat32;
  total_models : nat32;
  total_chunks : nat64;
  active_inference_sessions : nat32;
  last_updated : nat64;
  total_storage_used_bytes : nat64;
  ready_models : nat32;
  deployed_models : nat32;
};
type ModelInfo = record {
  quantization_format : QuantizationFormat;
  size_bytes : nat64;
  activated_at : opt nat64;
  version : text;
  state : ModelState;
  model_id : text;
  accuracy_retention : opt float32;
  compression_ratio : opt float32;
  uploaded_at : nat64;
};
type ModelManifest = record {
  metadata : vec record { text; text };
  activated_at : opt nat64;
  quantization : QuantizedArtifactMetadata;
  total_size_bytes : nat64;
  version : text;
  state : ModelState;
  chunk_count : nat32;
  checksum : text;
  chunks : vec ArtifactChunkInfo;
  model_id : text;
  uploaded_at : nat64;
};
type ModelState = variant { Active; Deprecated; Pending };
type ModelStatus = variant { Uploading; Failed; Ready; Deployed; Deleted };
type ModelUploadRequest = record {
  metadata : vec record { text; text };
  model_type : text;
  name : text;
  quantization : QuantizedArtifactMetadata;
  description : text;
  version : text;
  chunks : vec ArtifactChunkUpload;
};
type ModelUploadResponse = record {
  total_size_bytes : nat64;
  upload_time : nat64;
  chunk_count : nat32;
  checksum : text;
  model_id : text;
};
type OHMSError = variant {
  InvalidInput : text;
  NetworkError : text;
  NotFound : text;
  Unauthorized : text;
  AlreadyExists : text;
  CompressionFailed : text;
  InternalError : text;
  CommunicationFailed : text;
  InvalidState : text;
  QuotaExceeded : text;
  InsufficientFunds : text;
  ModelNotReady : text;
};
type QuantizationFormat = variant { NOVAQ; GGUF; Custom : text };
type QuantizedArtifactMetadata = record {
  bits_per_weight : opt float32;
  artifact_checksum : text;
  notes : opt text;
  accuracy_retention : float32;
  compression_ratio : float32;
  format : QuantizationFormat;
};
type Result = variant { Ok : text; Err : OHMSError };
type Result_1 = variant { Ok; Err : OHMSError };
type Result_2 = variant { Ok : ModelInfo; Err : OHMSError };
type Result_3 = variant { Ok : ModelStatus; Err : OHMSError };
type Result_4 = variant { Ok : InferenceResponse; Err : OHMSError };
type Result_5 = variant { Ok : ModelUploadResponse; Err : OHMSError };
type SystemHealth = record {
  status : ComponentHealth;
  memory_usage_mb : float32;
  metrics : vec record { text; text };
  canister_id : principal;
  version : text;
  uptime_seconds : nat64;
  last_update : nat64;
};
service : () -> {
  create_inference_session : (text, principal) -> (Result);
  delete_model : (text) -> (Result_1);
  deploy_model : (text) -> (Result_1);
  get_canister_metrics : () -> (ModelCanisterMetrics) query;
  get_chunk : (text, text) -> (opt blob) query;
  get_manifest : (text) -> (opt ModelManifest) query;
  get_model_info : (text) -> (Result_2) query;
  get_model_status : (text) -> (Result_3) query;
  health_check : () -> (SystemHealth) query;
  list_active_models : () -> (vec ModelInfo) query;
  list_models : (opt principal) -> (vec ModelInfo) query;
  run_inference : (InferenceRequest) -> (Result_4);
  terminate_inference_session : (text) -> (Result_1);
  upload_model : (ModelUploadRequest) -> (Result_5);
}